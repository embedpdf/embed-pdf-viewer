---
title: Viewport Plugin
description: Provides the essential <Viewport /> component, acting as the scrollable container and layout manager for PDF content in Svelte.
searchable: true
---

# Viewport Plugin

The Viewport Plugin is a foundational element for any viewer. It provides the `<Viewport />` component, which acts as the scrollable "window" through which users see the PDF pages.

This plugin is designed for **multi-document layouts**. It manages metrics, scroll state, and dimensions independently for every open document, allowing you to build split-screen views, tabbed interfaces, or multi-window applications easily.

## Installation

The plugin is available as a separate NPM package.

```sh npm2yarn
npm install @embedpdf/plugin-viewport
```

## Registration

Import `ViewportPluginPackage` and add it to the `plugins` array.

```typescript {3, 12-14}
import { createPluginRegistration } from '@embedpdf/core'
// ... other imports
import { ViewportPluginPackage } from '@embedpdf/plugin-viewport/svelte'

const plugins = [
  // ... other essential plugins
  createPluginRegistration(DocumentManagerPluginPackage, { /* ... */ }),
  createPluginRegistration(ScrollPluginPackage),
  createPluginRegistration(RenderPluginPackage),

  // Register and configure the viewport plugin
  createPluginRegistration(ViewportPluginPackage, {
    viewportGap: 20, // Adds 20px of padding inside the viewport
  }),
]
```

## Usage

The plugin provides the `<Viewport />` component for the UI and stores for programmatic control.

### The `<Viewport />` Component

The `<Viewport />` component is the main scrollable container. You must provide a `documentId` to link the scroll container to the specific document state managed by the engine.

```svelte
<script lang="ts">
import { Viewport } from '@embedpdf/plugin-viewport/svelte';
import { Scroller } from '@embedpdf/plugin-scroll/svelte';

let { documentId }: { documentId: string } = $props();
</script>

<Viewport {documentId} class="h-full w-full bg-gray-100">
  <Scroller {documentId} {renderPage} />
</Viewport>
```

### Programmatic Scrolling

To scroll a specific document programmatically, use `useViewportCapability` to get the API, then use `.forDocument(id)` to target the specific viewport.

```svelte {2,6-7, 10}
<script lang="ts">
import { useViewportCapability } from '@embedpdf/plugin-viewport/svelte';

let { documentId }: { documentId: string } = $props();

const viewportCapability = useViewportCapability();
const viewport = $derived(viewportCapability.provides?.forDocument(documentId));

const scrollToTop = () => {
  viewport?.scrollTo({ x: 0, y: 0, behavior: 'smooth' });
};
</script>

<button onclick={scrollToTop}>Scroll to Top</button>
```

### Monitoring Scroll Activity

To react to scrolling events (e.g., to show a "Back to Top" button or hide a floating toolbar), use the `useViewportScrollActivity` store. This store returns the reactive state for a specific document.

```svelte
<script lang="ts">
import { useViewportScrollActivity } from '@embedpdf/plugin-viewport/svelte';

let { documentId }: { documentId: string } = $props();

// Pass a getter that returns the documentId to track
const scrollActivity = useViewportScrollActivity(() => documentId);
</script>

{#if scrollActivity.current.isScrolling}
  <span>Scrolling...</span>
{:else}
  <span>Idle</span>
{/if}
```

## Live Example

This example demonstrates a complete setup. It loads a document, passes the `documentId` to the components, and creates a toolbar that controls scrolling for that specific document.

import { ViewportExample } from '../../code-examples/headless/viewport-example';

<CodeExample 
  codePaths={[
    "../../examples/svelte-tailwind/src/examples/headless/viewport-example.svelte",
    "../../examples/svelte-tailwind/src/examples/headless/viewport-example-content.svelte"
  ]}
>
  <ViewportExample />
</CodeExample>

## API Reference

### Configuration (`ViewportPluginConfig`)

| Option | Type | Description |
| :--- | :--- | :--- |
| **`viewportGap`** | `number` | The padding (in pixels) to apply around the content inside the viewport. <br />**Default**: `10` |
| **`scrollEndDelay`** | `number` | The time in milliseconds after the last scroll event before the `isScrolling` state is set to `false`. <br />**Default**: `300` |

### Component: `<Viewport />`

A `div`-based component that acts as the scrollable container. It accepts all standard `div` attributes like `style` and `class`.

| Prop | Type | Description |
| :--- | :--- | :--- |
| **`documentId`** | `string` | **(Required)** The unique ID of the document this viewport is displaying. |

### Store: `useViewportCapability()`

Connects your component to the viewport's functions.

#### Returns

| Property | Type | Description |
| :--- | :--- | :--- |
| **`provides`** | `ViewportCapability \| null` | An object with methods to interact with the viewport system. |

#### `ViewportCapability` Methods

| Method | Description |
| :--- | :--- |
| **`forDocument(id)`** | Returns a `ViewportScope` object to control a specific document's viewport. |
| **`getViewportGap()`** | Returns the configured viewport gap. |
| **`isViewportMounted(id)`**| Returns true if the viewport for the given document ID is currently mounted in the DOM. |

#### `ViewportScope` Methods (Returned by `forDocument`)

| Method | Description |
| :--- | :--- |
| **`scrollTo(position)`** | Scrolls the viewport. `position`: `{ x, y, behavior?, center? }`. |
| **`getMetrics()`** | Returns current dimensions (width, height, scrollTop, scrollWidth, etc.). |
| **`isScrolling()`** | Returns `true` if the user is currently scrolling. |
| **`getBoundingRect()`**| Returns the `DOMRect` of the viewport container. |

### Store: `useViewportScrollActivity(documentId)`

A store for tracking the scroll state of a specific document.

#### Parameters

| Parameter | Type | Description |
| :--- | :--- | :--- |
| **`documentId`** | `() => string` | A getter function that returns the document ID to track. |

#### Returns (`ScrollActivity`)

| Property | Type | Description |
| :--- | :--- | :--- |
| **`isScrolling`** | `boolean` | `true` if the user is currently scrolling or a smooth scroll animation is in progress. |
| **`isSmoothScrolling`**| `boolean`| `true` only when a smooth scroll animation initiated by `scrollTo` is in progress. |
